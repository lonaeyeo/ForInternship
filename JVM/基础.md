## JVM初识

<img src="https://user-gold-cdn.xitu.io/2020/3/18/170ec6cbb7b888f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:67%;" /> 

**Java代码执行流程**

 java程序--（编译）-->字节码文件--（解释执行）-->操作系统（Win，Linux，Mac JVM）



### 栈的指令集架构和寄存器的指令集架构

`由于跨平台的设计，java指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器`
栈：跨平台性、指令集小、指令多；执行性比寄存器差
寄存器：指令少

### jvm生命周期

**1.启动**

通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的.

**2.执行**

- 一个运行中的java虚拟机有着一个清晰的任务：执行Java程序；
- 程序开始执行的时候他才运行，程序结束时他就停止；
- 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。

**3.退出**

- 程序正常执行结束
- 程序异常或错误而异常终止
- 操作系统错误导致终止
- 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且java安全管理器也允许这次exit或halt操作
- 除此之外，JNI规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况



### JVM内存划分

**方法区：**方法区是一个**线程之间共享**的区域。**常量，静态变量以及JIT编译后的代码都在方法区。主要用于存储已被虚拟机加载的类信息**，也可以称为“永久代”，垃圾回收效果一般，通过-XX：MaxPermSize控制上限。

**堆内存：**堆内存是**垃圾回收**的主要场所，也是线程之间共享的区域，主要用来**存储创建的对象实例**，通过-Xmx 和-Xms 可以控制大小。

**虚拟机栈（栈内存）：**栈内存中主要保存**局部变量、基本数据类型变量**以及**堆内存中某个对象的引用变量**。每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态链接，方法出口等信息。栈中的栈帧随着方法的进入和退出有条不紊的执行着出栈和入栈的操作。

**程序计数器：** 程序计数器是当前线程执行的**字节码的位置指示器**。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，是内存区域中唯一一个在虚拟机规范中**没有规定任何OutOfMemoryError情况**的区域。

**本地方法栈：** 主要是为JVM提供使用native 方法的服务。



## 内存分配与垃圾回收

<img src="https://uploadfiles.nowcoder.com/images/20191119/5459305_1574174322608_FF7C346F99A63BCCC8A62E1D2B2671BC" alt="图片说明" style="zoom:50%;" /> 

### JVM堆内存的分配：

JVM初始分配的堆内存由**-Xms**指定，默认是物理内存的1/64。JVM最大分配的堆内存由**-Xmx**指定，默认是物理内存的1/4。

默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制。空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。因此我们一般设置-Xms和-Xmx相等以避免在每次GC 后调整堆的大小。

通过参数**-Xmn2G** 可以设置年轻代大小为2G。通过**-XX:SurvivorRatio**可以设置年轻代中Eden区与Survivor区的比值，设置为8，则表示年轻代中Eden区与一块Survivor的比例为8：1。注意年轻代中有两块Survivor区域。

### 堆内存上对象的分配与回收：

我们创建的对象会**优先在Eden分配**，如果是**大对象（很长的字符串数组）则可以直接进入老年代**。虚拟机提供一个**-XX:PretenureSizeThreshold参数**，令大于这个参数值的对象直接在老年代中分配，**<u>避免在Eden区和两个Survivor区发生大量的内存拷贝</u>**。

另外，**长期存活的对象将进入老年代**，每一次**MinorGC（年轻代GC）**，对象年龄就大一岁，默认15岁晋升到老年代，通过**-XX:MaxTenuringThreshold设置晋升年龄。**

<u>***堆内存上的对象回收也叫做垃圾回收，那么垃圾回收什么时候开始呢？***</u>

垃圾回收主要是完成**清理对象，整理内存**的工作。上面说到GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代。新生代还分为一个Eden区和两个Survivor区。垃圾回收分为年轻代区域发生的Minor GC和老年代区域发生的Full GC，分别介绍如下。

**Minor GC（年轻代GC）:**
对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快。

**Full GC（老年代GC）:**
Full GC是指发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，**发生Full GC一般都会有一次Minor GC**。



**动态对象年龄判定：**

如果Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，那么**年龄大于等于该对象年龄的对象即可晋升**到老年代，不必要等到-XX:MaxTenuringThreshold。

**空间分配担保：**

发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。如果大于，则进行一次**Full GC（老年代GC）**，如果小于，则查看**HandlePromotionFailure设置是否允许担保失败**，如果允许，那只会进行一次**Minor GC**，如果不允许，则改为进行一次**Full GC**。



**解析：**

<u>**关于JVM堆内存上对象的分配与回收是面试中考察的重点**</u>，希望大家可以对相关知识点熟练掌握，并且清晰阐述各个关键概念。



### （5）JVM如何判定一个对象是否应该被回收？（重点掌握）

**答：** 判断一个对象是否应该被回收，主要是看其是否还有引用。判断对象是否存在引用关系的方法包括**引用计数法以及root根搜索方法**。

#### 引用计数法：

是一种比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为0的对象。此算法最致命的是**无法处理循环引用**的问题。

#### root根搜索方法：

root搜索方法的基本思路就是**通过一系列可以做为root的对象作为起始点**，从这些节点开始向下搜索。当**一个对象到root节点没有任何引用链接**时，则<u>证明此对象是可以被回收的</u>。以下对象会被认为是**root对象**：

- **栈内存中引用的对象**
- **方法区中静态引用和常量引用指向的对象**
- 被启动类（bootstrap加载器）加载的类和创建的对象
- Native方法中JNI引用的对象。



<u>***什么是对象的引用。***</u>

如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称为**这块内存代表一个引用**。JDK1.2以后将引用分为**强引用，软引用，弱引用和虚引用四种。**

- **强引用：**普通存在， P p = new P()，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。
- **软引用：**通过SoftReference类来实现软引用，在**内存不足的**时候会将这些软引用回收掉。
- **弱引用：**通过WeakReference类来实现弱引用，每次**垃圾回收的时候**肯定会回收掉弱引用。
- **虚引用：**也称为**幽灵引用或者幻影引用**，通过PhantomReference类实现。设置虚引用只是为了对象被回收时候收到一个系统通知。



## JVM垃圾回收算法

### 标记-清除算法（Mark-Sweep）



## JVM垃圾收集器

### Serial Old收集器

Serial Old是Serial收集器的老年代版本，也是**一个单线程收集器**。主要也是给在Client模式下的虚拟机使用。在Server模式下存在主要是做为CMS垃圾收集器的后备预案，**当CMS并发收集发生Concurrent Mode Failure时使用。**



### CMS（Concurrent Mark Sweep）收集器（老年代）

CMS收集器是**一种以获取最短回收停顿时间为目标**的收集器。CMS收集器是基于**标记-清除算法**实现的，是一种老年代收集器，通常与**ParNew**一起使用。

**CMS的垃圾收集过程分为4步：**

- **初始标记**：需要“Stop the World”，初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快。
- **并发标记**：是主要标记过程，这个标记过程是和用户线程并发执行的。
- **重新标记**：需要“Stop the World”，为了修正并发标记期间因**用户程序继续运作而导致标记产生变动**的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。
- **并发清除**：和用户线程并发执行的，基于标记结果来清理对象。

<img src="https://uploadfiles.nowcoder.com/images/20191103/5459305_1572753698425_F19C9085129709EE14D013BE869DF69B" alt="图片说明" style="zoom:50%;" /> 

<u>***如果在重新标记之前刚好发生了一次MinorGC，会不会导致重新标记阶段Stop the World时间太长？***</u>

不会的，在并发标记阶段其实还包括了一次并发的**预清理阶段**，虚拟机会主动**等待年轻代发生垃圾回收**，这样可以将重新标记对象引用关系的步骤放在并发标记阶段，有效降低重新标记阶段Stop The World的时间。

#### CMS垃圾回收器的优缺点分析

CMS以降低垃圾回收的停顿时间为目的，很显然其具有并发收集，停顿时间低的优点。

**缺点：**

- **对CPU资源非常敏感**，因为并发标记和并发清理阶段和用户线程一起运行，当CPU数变小时，性能容易出现问题。
- 收集过程中会产生**浮动垃圾**，所以不可以在老年代内存不够用了才进行垃圾回收，必须提前进行垃圾收集。通过参数**-XX:CMSInitiatingOccupancyFraction**的值来控制内存使用百分比。如果该值设置的太高，那么在CMS运行期间预留的内存可能无法满足程序所需，会出现**Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器**，会产生更长时间的停顿。
- **标记-清除方式会产生内存碎片**，可以使用参数**-XX：UseCMSCompactAtFullCollection**来控制是否开启内存整理（无法并发，默认是开启的）。参数**-XX:CMSFullGCsBeforeCompaction**用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。