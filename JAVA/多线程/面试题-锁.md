##### *锁*

无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

**偏向锁：**不需CAS去竞争锁；偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

**轻量锁：**

| 锁       | 优点                                                         | 缺点                                             | 适用场景                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ------------------------------------ |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 | 适用于只有一个线程访问同步块场景。   |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度。                   | 如果始终得不到锁竞争的线程使用自旋会消耗CPU。    | 追求响应时间。同步块执行速度非常快。 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU。                            | 线程阻塞，响应时间缓慢。                         | 追求吞吐量。同步块执行速度较长。     |

<img src="https://img-blog.csdnimg.cn/20190317183206697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYWRvd196ZWQ=,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 80%;" /> 



##### *死锁的四个必要条件*

互斥条件：一个资源只能被单独占用使用，直到被用完才会释放；

请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放；

不可剥夺条件：进程已获得的资源，在未被使用之前，不可被剥夺；

环路等待条件：发生死锁后，若干进程之间形成首位相接的循环等待资源关系。





##### *偏向锁换取过程*

<img src="https://img-blog.csdnimg.cn/20201122134341310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDgwODM5,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;" /> 

1. 检测锁对象的MarkWord是否为可偏向状态，即是否为偏向锁标识1，锁标识位为01；
2. 如果为可偏向状态，判断线程ID是否指向当前线程，如果是进入步骤（5），否则进入步骤（3）。若为不可偏状态，直接升级为轻量级锁，进入轻量级锁逻辑。
3. 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。
4. 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。
5. 执行同步代码。

<img src="https://img-blog.csdnimg.cn/20201127162827784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDgwODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:80%;" />  



##### *偏向锁的释放*

偏向锁使用了一种等到竞争出现才释放偏向锁的机制：偏向锁**只有遇到其他线程尝试竞争偏向锁时**，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。



##### *偏向锁的撤销（升级）*

**偏向锁释放失败**（其他线程通过CAS替换原来线程的ThreadID失败），说明当前存在多线程竞争锁的情况，则开始进行偏向锁的撤销（升级）。

1. **对持有偏向锁的线程进行撤销时，需要等待到达全局安全点**。当到达全局安全点（safepoint，代表了一个状态，在该状态下所有线程都是暂停的）时，获得偏向锁的线程被挂起。
2. 如果获得偏向锁的线程如果已经退出了临界区，也就是同步代码块执行完了，不存在锁竞争，那么这个时候争抢锁的线程可以基于 CAS 重新偏向当前线程，此过程称为重偏向。

3. 如果获得偏向锁的线程的**同步代码块还没执行完**，处于临界区之内，存在锁竞争，这个时候会**把原获得偏向锁的线程升级为轻量级锁**（标志位为“00”），并将指向当前线程的锁记录地址的指针放入对象头Mark Word，后唤醒持有锁的当前线程，进入轻量级锁的竞争模式。

**其他情况下的偏向锁撤销**

- **当对象计算过一致性哈希吗后**（Object::hashCode() 或 System::identityHashCode(Object)方法的调用，重写的hashCode方法则不会），**立即撤销偏向锁**。
- **调用 wait/notify 方法**



##### *批量重偏向、批量撤销*

**批量重偏向：**当一个锁对象类的撤销次数达到20次时，虚拟机会认为这个锁不适合再偏向于原线程，于是会在偏向锁撤销达到20次时让这一类锁尝试偏向于其他线程。

**批量撤销：**当一个锁对象类的撤销次数达到40次时，虚拟机会认为这个锁根本就不适合作为偏向锁使用，因此会将类的偏向标记关闭（0），之后现存对象加锁时**会升级为轻量级锁**，锁定中的偏向锁对象会被撤销，新创建的对象默认为无锁状态。



##### *偏向锁的关闭*

**偏向锁在JDK1.6、JDK1.7中是默认启用的，并且它在应用程序启动后几秒钟才被激活。**

JVM参数关闭延迟：-XX:BiasedLockingStartupDelay=0
如果你确定应用程序里**所有的锁通常情况下处于竞争状态**，则可以用以下参数关闭偏向锁，那么程序默认会**进入轻量级锁状态**：

JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false



##### *轻量级锁*

轻量级锁是JDK1.6时加入的新型锁机制，“轻量级” 是相对于使用操作系统的 互斥量 实现的传统锁而言的。

- 目的：同步周期内，没有多线程竞争的前提下（多线程之间交替执行同步代码块，没有发生竞争），避免使用互斥量带来的性能损耗。
- 原理：CAS + 自旋
- 特点：非阻塞同步、乐观锁



##### *monitor的获取和释放（重量级锁的获取和释放）*

1. 对于**重量级锁，获取锁的过程实际上就是获取monitor的过程**，释放锁的过程实际上就是释放monitor的过程。monitor的竞争获取是在ObjectMonitor的enter方法中，而释放则是在exit方法中。

2. 通过CAS尝试把monitor的_owner字段设置为当前线程，然后对_count++，若在设置_owner为当前线程时，发现原来的_owner指向当前线程，则说明当前线程再次进入monitor，还应让_recursions++；

3. 如果获取锁失败，则当前线程加入_EntryList，等待锁的释放；

4. 已获取锁的线程执行wait操作，则 _count–，_recursions–，设置_owner 为 null，然后当前线程加入 _WaitSet中，等待被唤醒。

5. 已获取锁的线程通过 **notify 唤醒 _WaitSet中的线程，被唤醒的线程继续竞争锁**。

6. 已获取锁的线程执行完同步代码块时，释放锁（ObjectMonitor.exit），_count–，_recursions–，若 _count = 0 ，则设置 _owner 为 null，然后**唤醒 _EntryList竞争锁**（竞争是非公平的）。

<img src="https://img-blog.csdnimg.cn/20201122154118569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDgwODM5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 50%;" />   

**Tip：**

Java中的wait、notify、notifyAll等方法依赖于ObjectMonitor对象内部方法来完成，这也就是为什么要在同步方法或同步代码块中调用他们的原因（需要先获取对象的锁），否则就会抛出 IllegalMonitorException 。

由于每个Java对象都可以关联一个Monitor对象，所以任何对象都是可以是锁对象，而基本数据类型不是对象，所以不能作为锁。



![img](https://img-blog.csdnimg.cn/20201128164047803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDgwODM5,size_16,color_FFFFFF,t_70)  



##### *自旋锁*

自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待（让该线程执行一段无意义的忙循环，**CPU忙等待**），而不是把该线程给阻塞，直到获得锁的线程释放锁之后，这个线程就可以马上获得到锁。

轻量级锁的竞争就是采用的自旋锁机制。

<img src="https://img-blog.csdnimg.cn/20201128133358577.jpg#pic_center" alt="在这里插入图片描述" style="zoom: 80%;" /> 

-  引入自旋锁的原因：互斥同步对性能最大的影响是阻塞的实现，因为**阻塞和唤醒线程需要用户态和内核态的相互转换，这些操作给系统的并发性能带来很大的影响**。

-  自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开启；在JDK1.6中默认开启。

-  自旋锁的缺点：自旋等待不能替代阻塞，虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。**如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好**；反之，自旋的线程就会白白消耗掉处理器的资源，它不会做任何有意义的工作，这样反而会带来性能上的浪费。

-  自旋等待的时间（自旋的次数）必须要有一个限度，**如果自旋超过了定义的时间仍然没有获取到锁，则应该进入阻塞状态**。通过参数-XX:PreBlockSpin可以调整自旋次数，默认的自旋次数为10。

-  自适应自旋锁：JDK1.6引入自适应的自旋锁，自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定： 在同一锁对象上，若线程刚刚的一次自旋操作成功过，那么JVM会认为这次自旋成功的可能性会很高，就多自旋几次；反之，就少自旋甚至不自旋。

-  适用范围：适用于临界区代码少，执行快、锁竞争频率较低的情况。



##### *锁比较*

|  **锁**  |                           **优点**                           |                     **缺点**                     |             **适用场景**             |
| :------: | :----------------------------------------------------------: | :----------------------------------------------: | :----------------------------------: |
|  偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 |  适用于只有一个线程访问同步块场景。  |
| 轻量级锁 |          竞争的线程不会阻塞，提高了程序的响应速度。          |  如果始终得不到锁竞争的线程使用自旋会消耗CPU。   | 追求响应时间。同步块执行速度非常快。 |
| 重量级锁 |              线程竞争不使用自旋，不会消耗CPU。               |             线程阻塞，响应时间缓慢。             |   追求吞吐量。同步块执行速度较长。   |

