# 线程基础

### 线程与进程

**进程**是系统进行**资源分配和调度**的一个独立单位；

**线程**是进程的一个（多个）实体，线程之间**共享地址空间**和其它资源（所以通信和同步等操作,线程比进程更加容易）。注意ThreadLocal。

<u>***线程上下文切换比进程上下文切换快的原因。***</u>

- 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行的进程的CPU环境的设置；
- 线程切换时，仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。

**<u>*进程之间常见的通信方式：*</u>**

- 通过套接字Socket来实现不同机器间的进程通信
- 通过映射一段可以被多个进程访问的共享内存来进行通信
- 通过写进程和读进程利用管道（Pipe）进行通信



### 多线程与单线程

- 在单核CPU中，将CPU分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用CPU的机制。由于**CPU轮询**的速度非常快，所以看起来像是“同时”在执行一样；
- 多线程会存在**线程上下文切换**，会导致程序执行速度变慢
- 多线程不会提高程序的执行速度，反而会降低速度。但是对于用户来说，可以**减少用户的等待响应时间，提高了资源的利用效率**

**多线程并发利用了CPU轮询时间片的特点**，在一个线程进入阻塞状态时，可以快速切换到其余线程执行其余操作，这有利于**提高资源的利用率，最大限度的利用系统提供的处理能力**，**有效减少了用户的等待响应时间**。

但是，多线程并发编程也会带来数据的安全问题，线程之间的竞争也会导致线程死锁和锁死等**活性故障**。线程之间的上下文切换也会带来**额外的开销**等问题。



### 线程状态

线程状态包括 **新建状态，运行状态，阻塞等待状态和消亡状态。**其中阻塞等待状态又分为**BLOCKED, WAITING和TIMED_WAITING**状态。

所有的状态如下所示：

- **NEW**
- **RUNNABLE**
- **BLOCKED：**当线程准备进入synchronized同步块或同步方法的时候，需要申请一个监视器锁而进行的等待，会使线程进入BLOCKED状态。
- **WAITING：**调用了**Object.wait（）或者Thread.join（）或者LockSupport.park（）**。处于该状态下的线程在等待另一个线程 执行一些其余action来将其唤醒。
- **TIMED_WAITING（就绪状态）：**该状态和上一个状态其实是一样的，是不过其等待的时间是明确的。
- **TERMINATED**



### 线程活性故障

由于资源的稀缺性或者程序自身的问题导致线程**一直处于非Runnable状态**，并且其处理的任务**一直无法完成的现象**被称为是线程活性故障。常见的线程活性故障包括**死锁，锁死，活锁与线程饥饿**。



### 线程死锁

死锁的起因是多个线程之间相互等待对方而被永远暂停（处于非Runnable）。死锁的产生必须满足如下**四个必要条件：**

- **资源互斥**：一个资源每次只能被一个线程使用（资源不共享性）
- **请求与保持条件**：一个线程因请求资源而阻塞时，对已获得的资源保持不放（持续占有性）
- **不剥夺条件**：线程已经获得的资源，在未使用完之前，不能强行剥夺（不可抢夺性）
- **循环等待条件**：若干线程之间形成一种头尾相接的循环等待资源关系（循环性）

**<u>*如何避免死锁的发生？*</u>**

- **粗锁法：**使用一个粒度粗的锁来消除“请求与保持条件”，缺点是会明显降低程序的并发性能并且会导致资源的浪费。

- **指定获取锁的顺序**，比如某个线程只有获得A锁和B锁，才能对某资源进行操作，在多线程条件下，如何避免死锁？通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种方法。

- 使用**显式锁**中的**ReentrantLock.try(long,TimeUnit)**来申请锁。



  



