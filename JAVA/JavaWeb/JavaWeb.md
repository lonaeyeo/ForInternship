##### *Jsp和servlet*

Web容器将**JSP的代码编译成JVM能够识别的java类。**（JSP本质是Servlet；JVM只能识别java的类，不能识别jsp代码）；

jsp页面显示，servlet逻辑控制；

Servlet中无内置对象，JSP中的内置对象都必须通过<u>HttpServletRequest对象、HttpServletResponse对象以及HttpServlet对象得到</u>。

JSP是Servlet的一种简化，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。



##### *JSP内置对象及作用*

9个内置对象：

- request：**封装客户端的请求**，包含来自GET或POST请求的参数；
- response：**封装**服务器对客户端的**响应**；
- pageContext：通过该对象可以获取其他对象；
- session：封装用户会话的对象；
- application：封装服务器**运行环境的对象**；
- out：输出服务器响应的输出流对象；
- config：Web**应用的配置对象**；
- page：JSP**页面本身**（相当于Java程序中的**this**）；
- exception：封装页面抛出异常的对象。



##### *JSP的4种作用域*

JSP中的四种作用域包括page、request、session和application，具体来说：

- **page**代表与一个页面相关的对象和属性。
- **request**代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。
- **session**代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。
- **application**代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。



##### *session和cookie的区别*

- 由于HTTP协议是无状态的协议，所以**服务端需要记录用户的状态**时，就需要**用某种机制来识具体的用户**，这个机制就是Session。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用于**标识这个用户**，并且跟踪用户，这样才知道购物车里面有几本书。这个**Session是保存在服务端的**，有一个唯一标识。在服务端**保存Session的方法**很多，**内存**、**数据**库、**文件**都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。

- 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。**每次HTTP请求**的时候，**客户端**都**会发送相应的Cookie信息**到服务端。实际上**大多数的应用都是用 Cookie 来实现Session跟踪的**，

  a. 第一次创建Session的时候，服务端**会在HTTP协议中告诉客户端**，需要**在 Cookie 里面记录一个Session ID**，**以后**每次请求把这个**会话ID发送到服务器**，**我就知道你是谁了**。

  b. *如果客户端的浏览器禁用了 Cookie 怎么办？*一般这种情况下，会使用一种叫做**URL重写**的技术来进行会话跟踪，即每次HTTP交互，URL后面都会**被附加上一个诸如 sid=xxxxx 这样的参数**，服务端据此来识别用户。

- Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。

- 总结一下：**Session是在服务端保存的一个数据结构**，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。



##### *Session工作原理*

其实session是一个存在服务器上的类似于一个**散列表格**的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于**一个大号的map**吧，里面的**键存储的是用户的sessionid**，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。



##### *如果客户端禁止 cookie 能实现 session 还能用吗？*

Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。

假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：

1. 设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“--enable-trans-sid”选项，让PHP自动跨页传递Session ID。
2. 手动通过**URL传值**、隐藏表单传递Session ID。
3. 用文件、数据库等形式保存Session ID，**在跨页过程中手动调用**。



##### *如何避免sql注入*

SQL注入是比较常见的**网络攻击**方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编程时的疏忽，通过SQL语句，实现无帐号登录，甚至篡改数据库。

<u>SQL注入攻击的总体思路</u>

1.寻找到SQL注入的位置。

2.判断服务器类型和后台数据库类型。

3.针对不通的服务器和数据库特点进行SQL注入攻击；

举个栗子：

```mysql
从理论上说，后台认证程序中会有如下的SQL语句：
String sql = "select * from user_table where username= 
' "+userName+" ' and password=' "+password+" '";

当输入了上面的用户名和密码，上面的SQL语句变成：
SELECT * FROM user_table WHERE username= ' 'or 1 = 1 -- and password=''
```

再举个栗子：

```mysql
SELECT * FROM user_table WHERE username='' ;DROP DATABASE (DB Name) --' and password=''
```

**应对方法：**

###### 1.（简单又有效的方法）PreparedStatement

采用**预编译语句集**，它内置了处理SQL注入的能力，只要使用它的**setXXX**方法传值即可。

使用好处：

(1). 代码的可读性和可维护性；

(2). PreparedStatement尽最大可能提高性能；

(3). 最重要的一点是极大地提高了安全性。

原理：

sql注入只对sql语句的**准备(编译)过程**有破坏作用，而PreparedStatement已经准备好了，执行阶段只是把输入串作为数据处理，而不再对sql语句进行解析、准备，因此也就避免了sql注入问题。

###### 2. 使用正则表达式过滤传入的参数

```java
正则表达式：
private String CHECKSQL = “^(.+)\\sand\\s(.+)|(.+)\\sor(.+)\\s$”;

判断是否匹配：
Pattern.matches(CHECKSQL,targerStr);

下面是具体的正则表达式：
检测SQL meta-characters的正则表达式 ：
/(\%27)|(\’)|(\-\-)|(\%23)|(#)/ix

修正检测SQL meta-characters的正则表达式 ：/((\%3D)|(=))[^\n]*((\%27)|(\’)|(\-\-)|(\%3B)|(:))/i

典型的SQL 注入攻击的正则表达式 ：/\w*((\%27)|(\’))((\%6F)|o|(\%4F))((\%72)|r|(\%52))/ix

检测SQL注入，UNION查询关键字的正则表达式 ：/((\%27)|(\’))union/ix(\%27)|(\’)

检测MS SQL Server SQL注入攻击的正则表达式：/exec(\s|\+)+(s|x)p\w+/ix

等等…..
```

###### 3. 字符串过滤（有似同上）



###### 4. JSP中调用该函数检查是否包函非法字符



###### 5. 页面中判断代码

使用javascript在客户端进行不安全字符屏蔽



##### *什么是 XSS 攻击，如何避免？*

XSS攻击又称CSS,全称**Cross Site Script**（跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中**输入恶意的 HTML 代码**，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。

**XSS 攻击类似于 SQL 注入攻击**，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。

XSS防范的总体思路是：

- **对输入(和URL参数)进行过滤**，
- **对输出进行编码**。



##### *什么是 CSRF 攻击，如何避免？*

CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫**跨站请求伪造**。一般来说，攻击者通过**伪造用户的浏览器的请求**，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。

常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。

**<u>*如何避免：*</u>**

1. 验证 HTTP **Referer** 字段

   HTTP头中的Referer字段记录了**该 HTTP 请求**的**来源地址**。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF攻击，他一般只能在他自己的网站构造请求。因此，可以**通过验证Referer值来防御CSRF 攻击**。

2. 使用验证码

   **关键操作页面加上验证码**，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。

3. 在请求地址中**添加token并验证**

   CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该**请求中所有的用户验证信息都是存在于cookie**中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。

   可以**在 HTTP 请求中**以**参数的形式**加入**一个随机产生的 token**，并在服务器端**建立一个拦截器来验证这个 token**，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。<u>这种方法要比检查 Referer 要安全一些</u>，token 可以在用户登陆后产生并放于session之中，然后在**每次请求时把token 从 session 中拿出，与请求中的 token 进行比对**，但这种方法的难点在于如何把 token 以参数的形式加入请求。
   对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。
   而对于 POST 请求来说，要在 form 的最后加上 <input type="hidden" name="csrftoken" value="tokenvalue"/>，这样就把token以参数的形式加入请求了。

4. 在**HTTP 头中自定义属性**并验证

   这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它**放到 HTTP 头中自定义的属性里**。

   通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，**通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏**，也不用担心 token 会透过 Referer 泄露到其他网站中去。



##### *http 响应码 301 和 302 代表的是什么？有什么区别？*

重定向，资源位置发生变化，需要用户重新发送请求。

- 301 redirect: 301 代表永久性转移(Permanently Moved)。
- 302 redirect: 302 代表暂时性转移(Temporarily Moved )。



##### *forward 和 redirect 的区别*

Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。

**直接转发方式**（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。

**间接转发方式**（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。

举个栗子：

直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；

间接转发就相当于：“A找B借钱，B说没有，让A去找C借”。



##### *简述 tcp 和 udp的区别*

- TCP**面向连接**（如打电话要先拨号建立连接）;UDP是**无连接的**，即发送数据之前不需要建立连接。
- TCP提供**可靠**的服务。也就是说，通过TCP连接传送的数据，**无差错**，**不丢失**，**不重复**，且**按序到达**；UDP尽最大努力交付，即**不保证可靠交付**。
- TCP通过**校验和**，**重传控制**，序号标识，滑动窗口、**确认应答**实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
- UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
- 每一条**TCP连接只能是点到点的**;UDP支持一对一，一对多，多对一和多对多的交互通信。
- TCP对系统资源要求较多，UDP对系统资源要求较少。



##### *tcp 为什么要三次握手，两次不行吗？为什么？*

为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。

如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。



##### *tcp 粘包是怎么产生的*

①. 发送方产生粘包

采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；

但当发送的**数据包太小**时，那么TCP协议默认**会启用Nagle算法**，将这些较小的数据包进行**合并发送**（缓冲区数据发送是一个堆压的过程）；这个**合并过程在发送缓冲区中进行**的，也就是说数据发送出来它已经是**粘包**的状态了。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190403202154257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMTMyNTE2OTAyMQ==,size_16,color_FFFFFF,t_70)   

②. 接收方产生粘包

接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是程序中调用的读取数据函数**不能及时的把缓冲区中的数据拿出来**，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（**放数据的速度 > 应用层拿数据速度**）

<img src="https://img-blog.csdnimg.cn/20190403202229293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpMTMyNTE2OTAyMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />  



##### ***get 和 post 请求有哪些区别***

- GET在浏览器**回退时是无害的**，而POST会**再次提交请求**。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求**只能**进行**url编码**，而POST支持**多种编码**方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数**是有长度限制的**，而POST么有。
- 参数的数据类型，**GET只接受ASCII字符**，而POST没有限制。
- GET比POST更不安全，因为**参数直接暴露在URL上**，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST**放在Request body**中。



##### *什么是跨域*

<img src="C:\Users\lonaeyeo\AppData\Roaming\Typora\typora-user-images\image-20210424183819060.png" alt="image-20210424183819060" style="zoom: 80%;" />  



##### *跨域的解决方案*

···



