##### *数据库的三范式*

第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。
第三范式：任何非主属性不依赖于其它非主属性。



##### *一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？*

表类型如果是 MyISAM ，那 id 就是 8。
表类型如果是 InnoDB，那 id 就是 6。

InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。



##### *ACID*

1. **Atomicity（原子性）：**一个**事务**（transaction）中的**所有操作**，或者**全部完成**，或者**全部不完成**，不会结束在中间某个环节。事务在执行过程中**发生错误**，会被**恢复**（Rollback）**到事务开始前的状态**，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
2. **Consistency（一致性）：**在**事务开始之前**和**事务结束以后**，**数据库的完整性没有被破坏**。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
3. **Isolation（隔离性）：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以**防止多个事务并发执行时由于交叉执行而导致数据的不一致**。事务隔离分为不同级别，包括**读未提交**（Read uncommitted）、**读提交**（read committed）、**可重复读**（repeatable read）和**串行化**（Serializable）。
4. **Durability（持久性）：**事务处理结束后，对数据的**修改**就是永久的，即便**系统故障也不会丢失**。

<img src="https://static001.geekbang.org/resource/image/7d/f8/7dea45932a6b722eb069d2264d0066f8.png" alt="img" style="zoom: 33%;" />  

- 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
- 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
- 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。



##### *char 和 varchar 的区别*

1. char(n) ：固定长度类型，比如订阅 char(10)，当你输入"`abc`"三个字符的时候，它们**占的空间还是 10 个字节**，其他 7 个是空字节。
   char 优点：效率高；

   缺点：占用空间；

   适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。

2. varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。
   所以，**从空间上考虑 varchar比较合适**；从效率上考虑 char 比较合适，二者使用需要权衡。



##### *float 和 double 的区别*

float 最多可以存储 8 位的十进制数，并在内存中占 4 B。
double 最可可以存储 16 位的十进制数，并在内存中占 8 B。



##### *MySQL的内连接、左连接、右连接有什么区别*

- 内连接关键字：inner join，把匹配的关联数据显示出来；
- 左连接：left join，左边的表全部显示出来，右边的表显示出符合条件的数据；
- 右连接：right join，正好相反。



##### *行锁和表锁*

MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。

表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。
行级锁：**开销大**，**加锁慢**，会出现**死锁**。**锁力度小**，发生**锁冲突的概率小**，并发度最高。



##### *乐观锁和悲观锁*

**乐观锁：**每次去拿数据的时候都认为别人不会修改，所以**不会上锁**，但是在**提交更新的时候**会**判断一下在此期间别人有没有去更新这个数据**。
**悲观锁：**每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。

数据库的乐观锁需要自己实现，**在表里面添加一个 version 字段，每次修改成功值加 1**，这样每次修改的时候**先对比一下**，自己**拥有的 version 和数据库现在的 version 是否一致**，如果不一致就不修改，这样就实现了乐观锁。



##### *mysql 问题排查都有哪些手段*

- 使用 show processlist 命令查看当前所有连接信息；

- 使用 explain 命令查询 SQL 语句执行计划；

  开启慢查询日志，查看慢查询的 SQL。



##### *mysql 的性能优化*

1. 为搜索字段**创建索引**；
2. **避免使用 select ***，列出需要查询的字段；
3. 垂直分割分表；
4. 选择正确的存储引擎。