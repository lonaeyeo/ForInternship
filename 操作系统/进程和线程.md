```
"Competition is a painful thing, but it produces great results."
```

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9T1sqzavqAH3VIDxicaEtYMUwiagKpYBM5szUKj1F8KrkmuD99YokVuYg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />  

## 进程

我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个**运行中的程序，就被称为「进程」**。 

当运行到读取文件的指令时，就会去从硬盘读取数据，但是硬盘的读写速度是非常慢的，如果 CPU 傻傻地等硬盘返回数据的话，那 CPU 的利用率是非常低的。

当进程要从硬盘读取数据时，CPU 不需要阻塞等待数据的返回，而是去执行另外的进程。当硬盘数据返回时，CPU 会收到个**中断**，于是 CPU 再继续运行这个进程。

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9ROKhytS0ATz3KUictSI0rDntHcibw6wdfrJyDgvVgxdicEic6jkRW0692A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

虽然单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，它可能会运行多个进程，这样就产生**并行的错觉**，实际上这是**并发**。

**<u>*经典：并行和并发有什么区别*</u>**

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9kkSqrpkMYqI035yU7Ricpv368zOBOCicrk5EOMf7T5j9UicUvficEQdCxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

**CPU 可以从一个进程（做菜）切换到另外一个进程（买可乐），在切换前必须要记录当前进程中运行的状态信息，以备下次切换回来的时候可以恢复执行。**

所以，进程有着「**运行 - 暂停 - 运行**」的活动规律。



### 进程的状态

**在一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。**

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9EfRviciaGMLREQ1nqvjWkibKlREGPI9JyfhA5XlmzFRRiaIATAEiaLbCx4w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

上图中各个状态的意义：

- **运行状态（*Runing*）：**该时刻进程占用 CPU；
- **就绪状态（*Ready*）：**可运行，但因为其他进程正在运行而暂停停止；
- **阻塞状态（*Blocked*）：**该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；

当然，进程另外两个基本状态：

- **创建状态（*new*）：**进程正在被创建时的状态；
- **结束状态（*Exit*）：**进程正在从系统中消失时的状态；

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9gjKOC2IyZwLJXMcqzgvpKia0u1ezepiawX0iaFkrvsLeV6qsHplv5grnw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 



#### 状态变迁

- **NULL** ---> **创建状态**：一个新进程被创建时的第一个状态；
- **创建状态** ---> **就绪状态**：当进程被创建完成并初始化后，一切就绪准备运行时，变为就绪状态，这个过程是很快的；
- **就绪状态** ---> **运行状态**：处于就绪状态的进程被操作系统的<u>进程调度器选中后</u>，就<u>分配给 CPU</u> 正式运行该进程；
- **运行状态** ---> **结束状态**：当进程已经运行<u>完成或出错</u>时，会<u>被操作系统作结束状态处理</u>；
- **运行状态** ---> **就绪状态**：处于运行状态的进程在运行过程中，由于<u>分配给它的运行时间片用完</u>，操作系统会把该进程变为就绪态，接着从就绪态选中另外一个进程运行；
- **运行状态** ---> **阻塞状态**：当进程<u>请求某个事件且必须等待</u>时，例如请求 I/O 事件；
- **阻塞状态** ---> **就绪状态**：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；

还有一个状态叫**挂起状态**，它表示进程没有占有物理内存空间（在硬盘）。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。

由于虚拟内存管理原因，进程的所使用的空间可能并没有映射到物理内存，而是在硬盘上，这时进程就会出现挂起状态，另外调用 sleep 也会被挂起。

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9dsvxg4PrqzwaWvVS4CUicfzjAvE4gqHib3duJQPD35CWNibNrzicEP8bwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

挂起状态可以分为两种：

- **阻塞挂起状态**：进程在外存（硬盘）并等待某个事件的出现；
- **就绪挂起状态**：进程在外存（硬盘），但只要进入内存，即刻立刻运行；

**七种状态变迁**：

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9OSw0O4hBZhsvyrPTCkXqwCg9QgtBfdrCsU90NaspiabyILN5QxmAYxQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 



### 进程的控制结构（尘世闲游）

在操作系统中，是用**进程控制块**（*process control block，PCB*）数据结构来描述进程的。

**PCB 是进程存在的唯一标识**，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

#### PCB信息

**进程描述信息：**

- 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；

**进程控制和管理信息：**

- 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
- **进程优先级：**进程抢占 CPU 时的优先级；

**资源分配清单：**

- 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。

**CPU 相关信息：**

- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。



#### PCB组织

通常是通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**。

通常是通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**。比如：

- 将所有处于就绪状态的进程链在一起，称为**就绪队列**；
- 把所有因等待某事件而处于等待状态的进程链在一起就组成各种**阻塞队列**；
- 另外，对于运行队列在单核 CPU 系统中则只有一个运行指针了，因为单核 CPU 在某个时间，只能运行一个程序。

那么，就绪队列和阻塞队列链表的组织形式如下图：

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9q2vgjxfNQq38MNmricWU9jicJtxKDqu8MiaFtvia2qJ7LVxjlsMCcRDShQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。

除了链接的组织方式，还有索引方式，它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。



#### 进程的控制

**01 创建进程**

操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。

创建进程的过程如下：

- 为新进程分配一个**唯一的进程标识号**，并**申请一个空白的 PCB**，PCB 是有限的，若申请失败则创建失败；
- 为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源；
- **初始化 PCB**；
- 如果进程的调度队列能够接纳新进程，那就将进程插入到就绪队列，等待被调度运行；

**02 终止进程**

进程可以有 3 种终止方式：正常结束、异常结束以及外界干预（信号 `kill` 掉）。

终止进程的过程如下：

- 查找需要终止的进程的 PCB；
- 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；
- 如果**其还有子进程**，则应<u>将其所有子进程终止</u>；
- 将该进程所拥有的全部资源都归还给父进程或操作系统；
- 将其**从 PCB 所在队列中删除**；

**03 阻塞进程**

当进程**需要等待某一事件完成时**，它可以**调用阻塞语句把自己阻塞等待**。而一旦被阻塞等待，它只能由另一个进程唤醒。

阻塞进程的过程如下：

- 找到将要被阻塞进程标识号对应的 PCB；
- 如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行；
- 将该 PCB 插入的阻塞队列中去；

**04 唤醒进程**

进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以处于阻塞状态的进程是绝对不可能叫醒自己的。

**如果某进程正在等待 I/O 事件，需由别的进程发消息给它**，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。

唤醒进程的过程如下：

- 在该事件的阻塞队列中找到相应进程的 PCB；
- 将其从阻塞队列中移出，并置其状态为就绪状态；
- 把**该 PCB 插入到就绪队列**中，等待调度程序调度；

进程的阻塞和唤醒是一对功能相反的语句，**如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句**。



#### 进程的上下文切换

**一个进程切换到另一个进程运行，称为进程的上下文切换**。

任务是交给 CPU 运行的，那么在每个任务运行前，CPU 需要知道任务从哪里加载，又从哪里开始运行。

所以，操作系统需要事先帮 CPU 设置好 **CPU 寄存器和程序计数器**。CPU 寄存器是 CPU 内部一个容量小，但是速度极快的内存（缓存）。程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。

所以说，CPU 寄存器和程序计数是 CPU 在运行任何任务前，所必须依赖的环境，这些环境就叫做 **CPU 上下文**。

**CPU 上下文切换**

先<u>把前一个任务的 CPU 上下文（CPU 寄存器和程序计数器）保存起来</u>，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

系统内核会存储保持下来的上下文信息，当<u>此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文</u>，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

**进程的上下文切换**

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

**进程的上下文切换不仅包含了<u>虚拟内存、栈、全局变量</u>等用户空间的资源，还包括了<u>内核堆栈、寄存器</u>等内核空间的资源。**

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9zkoWRzjcm7vsypa1ORR9N9GEEOTCdo3gPUULRuib0sZCYNgF3ibJh6YA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

进程的上下文开销很关键，开销越小越好。

**<u>*发生进程上下文切换有哪些场景？*</u>**

- 当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行；
- 系统资源不足（比如内存不足）时，此进程也会被挂起，并由系统调度其他进程，知道资源能满足此进程；
- 进程sleep主动挂起，自然也会有重新调度；
- 优先级更高的进程出现，当前进程将被挂起，高优先级的线程来运行；
- 硬件中断时。



## 线程

**线程是进程当中的一条执行流程**，线程之间可以并发运行且共享相同的地址空间。

同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程都**有独立一套的寄存器和栈**，这样可以确保线程的控制流是相对独立的。

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS96rc8W3QAycjLBS5jYp2WmeiasicDSMaXjfwlau4Jb0zGiaEbalcGuiaHMg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

线程的优点：

- 同时存在多个；
- 可并发执行；
- 共享地址和文件资源；

线程的缺点：

- 当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。

**举个栗子**，对于游戏的用户设计，则不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。

### 线程与进程的区别😎

|      |                   进程                   |                 线程                 |
| ---- | :--------------------------------------: | :----------------------------------: |
| 单位 | 资源（包括内存、打开的文件等）分配的单位 |            CPU 调度的单位            |
| 资源 |          拥有一个完整的资源平台          |              寄存器和栈              |
| 状态 |   就绪、阻塞、执行,状态之间的转换关系    | 同样具有就绪、阻塞、执行三种基本状态 |
| 开销 |                                          |    能减少并发执行的时间和空间开销    |
|      |                                          |                                      |

进程资源：虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。

**线程相比进程能减少开销**，体现在：

- 线程的创建时间比进程快，因为进程在创建的过程中，还**需要资源管理信息**，比如<u>内存管理信息</u>、<u>文件管理信息</u>，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
- 线程的**终止时间比进程快**，因为<u>线程释放的资源相比进程少很多</u>；
- **同一个进程内的线程切换比进程切换快**，因为线程具有相同的地址空间（虚拟内存共享），这意味着**同一个进程的线程都具有同一个页表**，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而**页表的切换过程开销是比较大的**；
- 由于同一进程的各线程间共享内存和文件资源，那么在**线程之间数据传递的时候，就不需要经过内核了**，这就使得线程之间的数据交互效率更高了；

所以，**<u>线程比进程不管是时间效率，还是空间效率都要高</u>**。



### 线程的上下文切换

线程与进程最大的区别在于：**线程是调度的基本单位，而进程则是资源拥有的基本单位**。

所谓操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。

- 当进程只有一个线程时，可以认为进程就等于线程；
- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源，**这些资源在上下文切换时是不需要修改的**。

但是线程也有自己的私有数据，比如**栈和寄存器**等，这些**在上下文切换时也是需要保存**的。

<u>*线程上下文切换的是什么？*</u>

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- 当两个线程是属于同一个进程，因为**虚拟内存是共享的**，所以在切换时，**虚拟内存这些资源就保持不动**，只需要**切换线程的私有数据**、**寄存器等不共享**的数据；

所以，线程的上下文切换相比进程，开销要小很多。



### 线程的实现

- **用户线程（User Thread）**：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；
- **内核线程（Kernel Thread）**：在内核中实现的线程，是由内核管理的线程；
- **轻量级进程（LightWeight Process）**：<u>在内核中来支持用户线程</u>；

<u>*用户线程如何理解？存在什么优势和缺陷？*</u>

用户线程是基于用户态的线程管理库来实现的，那么**线程控制块（\*Thread Control Block, TCB\*）** 也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。

<u>用户线程的整个线程管理和调度</u>，**操作系统是不直接参与的**，而是**由用户级线程库函数来完成线程的管理**（可用于不支持线程技术的操作系统），包括线程的创建、终止、同步和调度等。

#### 用户线程优缺点

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9VKQibYPpQ7ciceSx1KTWZiaZGpUGxXKnvmVp6B0CgiaS0mLibgD0DPR0vaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:40%;" /> 

用户线程的优点：

- 每个**进程**都有私有的TCB列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器）；
- 用户<u>线程的切换也是由线程库函数</u>来完成的，**无需用户态与内核态的切换**，所以速度特别快；

用户线程的缺点：

- 由于操作系统不参与线程的调度，如果**一个线程发起了系统调用而阻塞**，那进程所包含的用户线程都不能执行了；
- 当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。
- 由于时间片分配给进程，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；

#### 内核线程优缺点

**内核线程是由操作系统管理**的，线程**对应的 TCB 自然是放在操作系统里**的，这样线程的创建、终止和管理都是由操作系统负责。

内核线程模型：

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9uxupficzvHFqcR0kvxvmFCAePZpwpthTkPjklN52vK2iawjgYJQCq2icw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:40%;" /> 

内核线程的**优点**：

- 在一个进程当中，如果<u>某个内核线程发起系统调用而被阻塞</u>，并**不会影响**其他内核线程的运行；
- 分配给线程，**多线程的进程获得更多的 CPU 运行时间**；

内核线程的**缺点**：

- 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；
- 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，**系统开销比较大**；



### 轻量级进程

**轻量级进程（Light-weight process，LWP）**是<u>**内核支持**的**用户线程**</u>，一个进程可有一个或多个 LWP，**每个 LWP 是跟内核线程一对一映射的**，也就是 LWP 都是由一个内核线程支持。

在大多数系统中，**LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息**。

在 LWP 之上也是可以使用用户线程的，那么 LWP 与用户线程的对应关系就有三种：

- `1 : 1`，即一个 LWP 对应 一个用户线程；
- `N : 1`，即一个 LWP 对应多个用户线程；
- `N : N`，即多个 LMP 对应多个用户线程；

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9zjhlNXMSdJXyCVEFBxBXWXAs2usCbwCvFP2t7KZqvbhRBQFM5eP7nQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

**1 : 1 模式**

一个线程对应到一个 LWP 再对应到一个内核线程，如上图的进程 4，属于此模型。

- 优点：实现并行，**当一个 LWP 阻塞，不会影响其他 LWP**；
- 缺点：**每一个用户线程**，就产生**一个内核线程**，创建线程的开销较大。

**N : 1 模式**

如上图的进程 2，线程管理是在用户空间完成的，此模式中用户的线程对操作系统不可见。

- 优点：用户线程要开几个都没问题，且上下文切换发生用户空间，**切换的效率较高**；
- 缺点：**一个用户线程如果阻塞了**，**则整个进程都将会阻塞**，另外在多核 CPU  中，是没办法充分利用 CPU 的。

**M : N 模式**

根据前面的两个模型混搭一起，就形成 `M:N` 模型，该模型提供了两级控制，首先多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程，如上图的进程 3。

- 优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源。

**组合模式**

如上图的进程 5，此进程结合 `1:1` 模型和 `M:N` 模型。开发人员可以针对不同的应用特点调节内核线程的数目来达到物理并行性和逻辑并行性的最佳方案。



## 调度

调度程序（scheduler）

### 调度时机

*From 就绪态 ---> 运行态*

*From 运行态 ---> 阻塞态*

*From 运行态 ---> 结束态*

如果硬件时钟提供某个频率的周期性中断，那么调度算法可分为两类：

- **非抢占式调度算法**挑选一个进程，然后**让该进程运行直到被阻塞**，或者**直到该进程退出**，才会调用另外一个进程，也就是说不会理时钟中断这个事情。
- **抢占式调度算法**挑选一个进程，然后**让该进程只运行某段时间**，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生**时钟中断**，以便把 CPU 控制返回给调度程序进行调度，也就是常说的**时间片机制**。



### 调度原则

原则一：为了提高 CPU 利用率，在这种**发送 I/O 事件致使 CPU 空闲的情况**下，调度程序需要从就绪队列中选择一个进程来运行。

原则二：有的程序执行某个任务花费时间过长，如若一直占用CPU，会造成系统吞吐量降低（CPU在单位时间内完成的进程数量）的降低。因此，**要提高系统的吞吐率，调度程序要权衡长任务和短任务进程的运行完成数量。**

原则三：从进程开始到结束的过程中，包含进程运行时间和进程等待时间，总和称为周转时间。进程的周转时间越小越好，如果**进程的等待时间很长而运行时间很短**，那周转时间就很长，**调度程序应该避免这种情况发生**。

原则四：处于就绪队列的进程，也不宜等大久，所以，**就绪队列中进程的等待时间也是调度程序所需要考虑的原则。**

原则五：**对于交互式比较强的应用**（例如鼠标、键盘等这种交互式比较强的应用），响应时间也是调度程序需要考虑的原则。

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9ULntsJiaLaNBVfmpLlaWW6iaFhiaBibKgX010xnpcLa75UAysjGCuhmmHw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

针对上面的五种调度原则，总结成如下：

- **CPU 利用率**：调度程序应确保 CPU 始终匆忙，可提高 CPU 的利用率；
- **系统吞吐量**：（单位时间内 CPU 完成进程的数量），长作业的进程会占用较长的 CPU 资源，进而会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
- **周转时间**：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好；
- **等待时间**：此等待时间非阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；
- **响应时间**：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。



### 调度算法

<u>单核CPU系统常见的调度算法</u>

**01 先来先服务调度算法（First Come First Served, FCFS）**

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS98fL9oMpFYuF3H9JQSRmWic0uKWTSwgyBg2DhLtxEL3lDxfrDjcc89IA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。

**02 最短作业优先调度算法（Shortest Job First, SJF）**

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9xbov7SWYBLGwpNeRwgszZ0Wq85u3BVM8y8Kgnahpv24AHiakZNFxkvQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

显然对长作业不利。

**03 高响应比优先调度算法（Highest Response Ratio Next, HRRN）**

每次进行进程调度时，**先计算「响应比优先级」**，然后**把「响应比优先级」最高的进程投入运行**，「响应比优先级」的计算公式：

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9SiaDZLEEJFHib1gWcf507J91S97kmkdTNFu9ZEcWXZjS75vjRbNRcKJg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

从上面的公式，可以发现：

- 如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；
- 如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；

**04 时间片轮转调度算法（Round Robin, RR）**

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS91MIViarQcL8zfy7akiaiarT2cicW6Xic9nshjiaKsKu9a6rengP36maUPXNg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

**每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。**

- 如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；
- 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；

另外，时间片的长度就是一个很关键的点：

- 如果**时间片设得太短**会导致**过多的进程上下文切换**，降低了 CPU 效率；
- 如果**设得太长**又可能引起对短作业进程的**响应时间变长**。将

通常时间片设为 `20ms~50ms` 通常是一个比较合理的折中值。😏这里有个时间啊。

**05 最高优先级调度算法（Highest Priority First, HPF）**

进程的优先级可以分为，静态优先级或动态优先级：

- 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；
- 动态优先级：根据进程的动态变化调整优先级，比如**如果进程运行时间增加，则降低其优先级**，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是**随着时间的推移增加等待进程的优先级**。

该算法也有两种处理优先级高的方法，非抢占式和抢占式：

- 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。
- 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。

**缺点：**可能会导致低优先级的进程永远不会运行。

<u>**06 多级反馈队列调度算法（Multilevel Feedback Queue）**</u>

「时间片轮转算法」和「最高优先级算法」的综合和发展。

顾名思义：

- 「多级」表示**有多个队列**，每个队列优先级**从高到低**，同时优先级越高时间片越短。
- 「反馈」表示如果有新的进程加入优先级高的队列时，立刻**停止当前**正在运行的进程，**转而去运行优先级高的队列**；

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS97aZcCicujfW37OibX6choIianA2PsNZWC1bJQKAMjYfKHC7k2zkuplkuQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

来看看，它是如何工作的：

- 设置了多个队列，赋予**每个队列不同的优先级**，每个**队列优先级从高到低**，同时**优先级越高时间片越短**；
- <u>新的进程会被放入到第一级队列的末尾</u>，按**先来先服务的原则**排队等待被调度，如果在第一级队列规定的时间片<u>没运行完成</u>，则将其**转入到第二级队列的末尾**，<u>以此类推，直至完成</u>；
- 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有**新进程进入较高优先级的队列**，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行； 

总结一下：优先级越高**时间片越短**；<u>新来的先进第一级队列尾</u>；如果没完成，**自动转到下一级队尾**；如果有高优先级的加入，则暂停当前，<u>运行高优先级</u>。

可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的**兼顾了长短作业，同时有较好的响应时间。**



**举个栗子：**

时间片轮转：

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS95lRoQf7K0cK2PWF95IicLCqU8r7fvbsyeMHs1v5khd17d7UO43MM1dw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

最高优先级：

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9WVOiaGDpysDpqMAian3eprFibicVu4VdYW1jdcEFccLlV5bzia76HMniah5A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

多级反馈队列（MFQ）调度算法：

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcvw4t9kicec370n3cvX2JS9UUMwBVbgN2gdQib8C9AbDGaCmwUwhiaicsecVkywFJDCGp4rnWeZfvw6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

- 新客户（进程）来了，先进入第一级队列的末尾，按先来先服务原则排队等待被叫号（运行）。如果时间片用完客户的业务还没办理完成，则**让客户进入到下一级队列的末尾**，以此类推，直至客户业务办理完成。
- **当第一级队列没人排队时，就会叫号二级队列的客户。**如果客户办理业务过程中，有新的客户加入到较高优先级的队列，那么<u>此时办理中的客户需要停止办理</u>（不人道😳），回到原队列的末尾等待再次叫号，因为要把窗口让给刚进入较高优先级队列的客户。