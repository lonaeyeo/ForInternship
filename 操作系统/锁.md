## 死锁

死锁只有**同时满足**以下四个条件才会发生：

- 互斥条件
- 持有并等待条件
- 不可剥夺条件
- 环路等待条件



##### 互斥条件

<img src="https://mmbiz.qlogo.cn/mmbiz_png/J0g14CUwaZcUibyDdMtUl4a0Mh4JptI5OyogHIgicpibhaswiathIvb5nWeVKPSfiaZJFiaC8MESxjYRGwtLdP1Xw3BQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1&retryload=2" alt="图片" style="zoom: 67%;" />  

##### 持有并等待条件

<img src="https://mmbiz.qlogo.cn/mmbiz_png/J0g14CUwaZcUibyDdMtUl4a0Mh4JptI5OneC82tLlWEN0rZV0y82IUwbtNz0LApXkC7BBDrRQkroF9lHu7dlIKA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1&retryload=2" alt="图片" style="zoom: 67%;" />  

##### 不可剥夺条件

<img src="https://mmbiz.qlogo.cn/mmbiz_png/J0g14CUwaZcUibyDdMtUl4a0Mh4JptI5OyYErAFzpQuuhic1N2ah7Th86DF12ibQIWVuia13IaqL8IQNIDv20YcIbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1&retryload=2" alt="图片" style="zoom: 67%;" />  

##### 环路等待条件



#### 避免死锁问题的发生

避免死锁问题就只需要破环其中一个条件就可以，最常见的并且可行的就是**使用资源有序分配法来破环环路等待条件**。

***<u>那什么是资源有序分配法呢？</u>***

线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 1，然后尝试获取资源2的时候，线程 B 同样也是先尝试获取资源1，然后尝试获取资源2。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。

可以不改动线程 A 的代码。先要清楚线程 A 获取资源的顺序，它是先获取互斥锁 A，然后获取互斥锁 B。

所以只需将线程 B 改成以相同顺序的获取资源，就可以打破死锁了。

<img src="C:\Users\lonaeyeo\AppData\Roaming\Typora\typora-user-images\image-20210417211607646.png" alt="image-20210417211607646" style="zoom: 50%;" />  



## 互斥锁与自旋锁

互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：

- **互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；
- **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁；

互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，**既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞**。



### 自旋锁

自旋锁是通过 CPU 提供的 `CAS` 函数（*Compare And Swap*），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。

一般加锁的过程，包含两个步骤：

- 第一步，查看锁的状态，如果锁是空闲的，则执行第二步；
- 第二步，将锁设置为当前线程持有；

CAS 函数就**把这两个步骤合并成一条硬件级指令**，形成**原子指令**，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。

​	

## 读写锁

由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。

读写锁的工作原理是：

- **当「写锁」没有被线程持有时**，**多个线程能够并发地持有读锁**，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。
- 但是，**一旦「写锁」被线程持有后**，读线程的获取**读锁的操作会被阻塞**，而且其他写线程的获取写锁的操作也会被阻塞。

**写锁是独占锁**，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而**读锁是共享锁**，因为读锁可以被多个线程同时持有。

因此，***读写锁在读多写少的场景，能发挥出优势***。

#### 读优先锁

读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，工作方式：

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZflJahXjfiaG4OvTA9DA2UibzGiaX1mvYx5jzfQaYsG9hYbicIzos7M9SkKz0wWMoxBk9RwyguyWwtricA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" /> 

读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。



#### 写优先锁

优先服务写线程，其工作方式是：

<img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZflJahXjfiaG4OvTA9DA2UibzskMiariaXsTzJYibmXK6vGf9fWOlJI6oSaB0ibBIp40Gia5V0VsWclRvttw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" /> 

写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。



#### 公平读写锁

公平读写锁比较简单的一种方式是：**用队列把获取锁的线程排队**，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。



## 乐观锁与悲观锁

#### 悲观锁

前面提到的**互斥锁**、**自旋锁**、**读写锁**，都是属于**悲观锁**。

悲观锁做事比较悲观，它认为**多线程同时修改共享资源的概率比较高**，于是很**容易出现冲突**，所以访问共享资源前，**先要上锁**。



#### 乐观锁

如果**多线程同时修改共享资源的概率比较低**，就可以采用乐观锁。

乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：**先修改完共享资源**，**再验证这段时间内有没有发生冲突**，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。

乐观锁全程并没有加锁，所以它也叫**无锁编程**。

**举个栗子：**在线文档，

用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。

服务端要怎么验证是否冲突了呢？通常方案如下：

- 由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下**服务端返回的文档版本号**；
- 当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后**将它与当前版本号进行比较**，如果**版本号一致则修改成功**，否则提交失败。

实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。

乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。**



## 总结

开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「**线程切换**」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有**两次线程上下文切换**的成本，性能损耗比较大。

如果我们明确知道**被锁住的代码的执行时间很短**，那我们应该选择**开销比较小的自旋锁**，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个**忙等待的时间相对应也很短**。

如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁。

- 读优先锁并发性很强，但是写线程会被饿死；
- 写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题；
- 公平读写锁用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。

互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。

**互斥锁、自旋锁、读写锁都属于悲观锁**。

如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，**在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突**，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。

但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。

不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。